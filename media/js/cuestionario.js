var respuestas=[];
var correctas=[];
var aciertos;
var preguntas=[];
var calif = false;

function Pregunta (pregunta, respuesta1, respuesta2, respuesta3, respuesta4, res, state){
    this.pregunta = pregunta;
    this.respuesta1 = respuesta1;
    this.respuesta2 = respuesta2;
    this.respuesta3 = respuesta3;
    this.respuesta4 = respuesta4;
    this.res = res;
    this.state = state;
};

function cuestionario(){
    for(n = 0; n<15; n++){
        i = Math.floor(Math.random()*preguntas.length);;
        while (preguntas[i].state == false) {
            i = Math.floor(Math.random()*preguntas.length);;
        }
        document.write("<div class='pregunta'>");
        document.write("<h2>"+(n+1)+". "+preguntas[i].pregunta+"</h2><table id='pregunta'><tbody>");
        document.write("<tr><td><input type='radio' name='p"+i+"' value=0 onclick='respuesta("+n+","+0+")'>"+preguntas[i].respuesta1+"</td><td><input type='radio' name='p"+i+"' value=1 onclick='respuesta("+n+","+1+")'>"+preguntas[i].respuesta2+"</td>");
        document.write("<tr><td><input type='radio' name='p"+i+"' value=2 onclick='respuesta("+n+","+2+")'>"+preguntas[i].respuesta3+"</td><td><input type='radio' name='p"+i+"' value=3 onclick='respuesta("+n+","+3+")'>"+preguntas[i].respuesta4+"</td>");
        document.write('</tr></tbody></table></div>');
        correctas[n] = preguntas[i].res;
        preguntas[i].state = false;
    }
};

preguntas[0] = new Pregunta("(1)¿Cuáles son los dos métodos principales de minimización utilizados en la síntesis de circuitos lógicos?", "Mapa de Karnaugh y el algoritmo Quine-McCluskey (método tabula).", "Método Simplex y Método algebraico.", "Método gráfico de mapas de Karnaugh y Algebra de Boole.", "Todas las anteriores.", 0, true);
preguntas[1] = new Pregunta("(2)¿Cómo difieren en su aplicabilidad para funciones de más de 4 variables el mapa de Karnaugh y el método tabula (Quine-McCluskey) en la síntesis de circuitos lógicos?", "Mientras que el mapa de Karnaugh se vuelve complicado de analizar visualmente para funciones con más de 4 variables, el método tabula (Quine-McCluskey) es más adecuado y no presenta dificultades significativas al manejar funciones lógicas con un mayor número de variables.", "Mientras más complejo el mapa de Karnaugh, más complejo se vuelve el método de Quine McCluskey.", "No difieren en ningún momento.", "Ninguna de las anteriores.", 0, true);
preguntas[2] = new Pregunta("(3)¿Cuál es el Algoritmo Quine-McCluskey?", "El algoritmo Quine-McCluskey es un método de simplificación de funciones booleanas desarrollado por Willar Van Orman Quine y Edward J. McCluskey.", "Es un algoritmo de un método gráfico de simplificación de funciones logarítmicas desarrollado por Edward J. McCluskey y Bernhard Riemann.", "Es un método de simplificación de funciones desarrollado por Edward J. McCluskey y Grigori Perelmán.", "Todas las anteriores.", 0, true);
preguntas[3] = new Pregunta("(4)¿Cuáles son pasos principales en la simplificación de funciones booleanas?", "Involucra encontrar todos los implicantes primos de la función.", "Consiste en encontrar todos los implicantes irracionales que existen en la función.", "Encontrar los elementos fraccionarios dentro de la función simplificada.", "Todas las anteriores.", 0, true);
preguntas[4] = new Pregunta("(5)¿Qué es la representación cúbica de las funciones de Boole?", "La representación cubica de las funciones de Boole es una técnica gráfica que utiliza cubos para visualizar las combinaciones posibles de variables booleanas. En esta representación, una variable se muestra como un punto en un segmento, dos variables en un cuadrado, y tres variables en un cubo.", "Es una técnica tabular que utiliza cubos para visualizar las combinaciones posibles de variables.", "Representación de una sola combinación de una variable booleana.", "Ninguna de las anteriores.", 0, true);
preguntas[5] = new Pregunta("(6)¿Qué son los implicantes primos en el contexto del método de Quine-McCluskey?", "Los implicantes primos son cubos que no están completamente contenidos en otros cubos más grandes de una función booleana. Estos cubos se utilizan para simplificar la función.", "Los implicantes primos son cubos que se encuentran contenidos en cubos más pequeños de una función boolena.", "Los implicantes primos son cubos que se encuentran contenidos en cubos más pequeños de una función boolena. Estos cubos se utilizan para simplificar la función.", "Todas las anteriores.", 0, true);
preguntas[6] = new Pregunta("(7)¿Cómo se simplifican las funciones booleanas utilizando el método de Quine-McCluskey?", "El método de Quine-McCluskey simplifica funciones booleanas comparando mintérminos y combinándolos en cubos de orden superior. Se buscan los implicantes primos esenciales que cubren los mintérminos de la función, y luego se buscan implicantes primos secundarios de menor costo. La función simplificada se obtiene combinando estos implicantes primos.", "Se buscan implicantes compuestos al azar y luego implicantes primos esenciales, al combinarlos se obtiene la función simplificada.", "Selecciona un grupo de implicantes primos de menor valor y otro grupo de estos mismos, al final se combinan y la función queda simplificada.", "Ninguna de las anteriores.", 0, true);
preguntas[7] = new Pregunta("(8)¿Qué papel juegan los cubos en la representación cúbica de funciones booleanas?", "Los cubos se utilizan en la representación cúbica para visualizar las combinaciones posibles de variables booleanas. Cada cubo representa una combinación de variables y se utiliza para simplificar funciones booleanas mediante el método de Quine-McCluskey.", "Cada puede representar distintas combinaciones de variables y se utiliza para simplificar funciones booleanas.", "Son una representación cubica que visualiza una sola combinación de variables booleanas. Cada cubo es igual a diferentes combinaciones de variables y se utiliza en el método de Quine-McCluskey.", "Todas las anteriores.", 0, true);
preguntas[8] = new Pregunta("(9)¿Cuál es la ventaja de simplificar funciones booleanas utilizando el método de Quine- McCluskey?", "Obtener expresiones más compactas y eficientes, lo que facilita su implementación en circuitos electrónicos y reduce la complejidad. Esto mejora el rendimiento y reduce el costo de los circuitos lógicos.", "Obtener expresiones más complejas pero eficientes al implementarlas en circuitos eléctricos.", "Un mejor rendimiento en los circuitos eléctricos, pero aumentando su costo.", "Ninguna de las anteriores.", 0, true);
preguntas[9] = new Pregunta("(10)¿Qué implicantes se consideran primos esenciales en el algoritmo de Quine-McCluskey?", "Los implicantes primos esenciales son aquellos que no pueden ser reducidos más y que tienen solo un tache en la columna de números binarios.", "Son aquellos que si se pueden reducir y que tienen múltiples taches en la columna de números binarios.", "Aquellos que no pueden ser reducidos más y que tienen múltiples taches en la columna de números binarios.", "Ninguna de las anteriores.", 0, true);
preguntas[10] = new Pregunta("(11)¿Cuál es el propósito de la minimización de funciones booleanas en el diseño de circuitos lógicos?", "La minimización de funciones boolenas es esencial en el diseño de circuitos lógicos ya que afecta la complejidad del sistema, su costo y su implementación. El objetivo es representar una función booleana como la suma del menor número de términos, lo que permite simplificar el diseño de circuitos lógicos.", "Su objetivo es representar una función booleana como la resta del número mayor de términos, lo que nos daría un diseño más complejo, pero más útil.", "No tienen ningún objetivo, simplemente es tener el circuito de manera visual.", "Todas las anteriores.", 0, true);
preguntas[11] = new Pregunta("(12)¿Qué ventajas se mencionan en la versión decimal del algoritmo Quine-McCluskey con la modificación propuesta?", "Si importa con la necesidad de utilizar números adicionales en cada paso del algoritmo", "La ventaja es que permite tratar aritméticamente los términos No-Importa sin la necesidad de utilizar números adicionales en cada paso del algoritmo.", "No tiene ninguna ventaja la versión decimal del algoritmo Quine McCluskey.", "Ninguna de las anteriores.", 1, true);
preguntas[12] = new Pregunta("(13)¿Cómo se lleva a cabo la simplificación de funciones booleanas en la versión decimal del algoritmo Quine-McCluskey? ", "Lo términos se simplifican comparando sus valores decimales con los enteros y si la diferencia entre estos dos términos es múltiplo de 5, se genera un termino reducido.", "Los términos se simplifican comparando sus valores decimales, y si la diferencia entre dos términos es un múltiplo de 3, pueden generar un término reducido.", "Tomamos nuestro primer número decimal y si es múltiplo de 6, podemos generar su término reducido.", "Todas las anteriores.", 1, true);
preguntas[13] = new Pregunta("(14)¿Qué es la representación cúbica de las funciones de Boole?", "La representación cúbica de las funciones de Boole es una técnica gráfica que utiliza cubos para visualizar las combinaciones posibles de variables booleanas.", "Es una representación tabular de las funciones de Boole que visualiza las combinaciones posibles de diferentes variables.", "Es una técnica tabular que utiliza cubos para visualizar una sola variable booleana", "Ninguna de las anteriores.", 0, true);
preguntas[14] = new Pregunta("(15)¿Qué son los implicantes primos en el contexto del método de Quine-McCluskey?", "Los implicantes primos son cubos que no están completamente contenidos en otros cubos más grandes de una función booleana. Estos cubos se utilizan para simplificar la función.", "Los implicantes son cubos contenidos en cubos más pequeños de una función booleana. Se utilizan para simplificar la función.", "Cubos contenidos en cubos más grandes de una función y estos cubos hacen más compleja nuestra función, pero con más opciones para trabajarla.", "Todas las anteriores.", 0, true);
preguntas[15] = new Pregunta("(16)¿Cómo se simplifican las funciones booleanas utilizando el método de Quine-McCluskey?", "Comparando minitérminos y combinándolos en cubos de orden superior. Se buscan los implicantes primos esenciales que cubren los mintérminos de la función, y luego se buscan implicantes primos secundarios de menor costo. La función simplificada se obtiene combinando estos implicantes primos.", "No podemos simplificarlas, simplemente tenerlas de manera visual", "Combinando los implicantes primos.", "Ninguna de las anteriores.", 0, true);
preguntas[16] = new Pregunta("(17)¿Qué papel juegan los cubos en la representación cúbica de funciones booleanas?", "Los cubos se utilizan en la representación cúbica para visualizar las combinaciones posibles de variables booleanas. Cada cubo representa una combinación de variables y se utiliza para simplificar funciones booleanas mediante el método de Quine-McCluskey.", "Cada cubo representa distintas combinaciones de variables y nos muestra las funciones de manera más compleja.", "Los cubos nos muestran funciones más complejas, pero más útiles para trabajarlas.", "Todas las anteriores.", 0, true);
preguntas[17] = new Pregunta("(18)¿Cuál es la ventaja de simplificar funciones booleanas utilizando el método de Quine- McCluskey?", "La ventaja de simplificar funciones booleanas con el método de Quine-McCluskey es obtener expresiones más compactas y eficientes, lo que facilita su implementación en circuitos electrónicos y reduce la complejidad. Esto mejora el rendimiento y reduce el costo de los circuitos lógicos.", "No hay ninguna ventaja, al contrario, es más complejo utilizar el método de Quine- McCluskey.", "La ventaja de tener una función booleana más compleja pero más sencilla su implementación en circuitos electrónicos.", "Ninguna de las anteriores.", 0, true);
preguntas[18] = new Pregunta("(19)¿Qué implicantes se consideran primos esenciales en el algoritmo de Quine-McCluskey?", "Son aquellos que no pueden ser reducidos más y que tienen solo un tache en la columna de números binarios.", "Son aquellos que podemos reducir más y tienen múltiples taches en la columna de números binarios.", "Son aquellos que podemos reducir más y que tienen un solo tache en su columna de números binarios.", "Todas las anteriores.", 0, true);
preguntas[19] = new Pregunta("(20)¿Cuál es el propósito de la minimización de funciones booleanas en el diseño de circuitos lógicos?", "La minimización de funciones booleanas es esencial en el diseño de circuitos lógicos ya que afecta la complejidad del sistema, su costo y su implementación. El objetivo es representar una función booleana como la suma del menor número de términos, lo que permite simplificar el diseño de circuitos lógicos.", "Su objetivo es representar una función booleana como el producto del mayor número de términos, lo que permite simplificar el diseño de los circuitos lógicos.", "No existe ningún propósito.", "Ninguna de las anteriores.", 0, true);
preguntas[20] = new Pregunta("(21)¿Quiénes fueron los desarrolladores del Algoritmo de Quine-McCluskey?", "El Algoritmo de Quine-McCluskey fue desarrollado por Willard Van Orman Quine y Edward J. McCluskey.", "El Algoritmo de Quine-McCluskey fue desarrollado por George Boole y John McCluskey.", "El Algoritmo de Quine-McCluskey fue desarrollado por Alan Turing y Charles Babbage.", "Todas las anteriores.", 0, true);
preguntas[21] = new Pregunta("(22)¿Cuál es el propósito principal del Algoritmo de Quine-McCluskey en la simplificación de funciones booleanas?", "El propósito principal del Algoritmo de Quine-McCluskey es simplificar funciones booleanas, reduciendo la complejidad y el número de términos en sus expresiones.", "El propósito principal del Algoritmo de Quine-McCluskey es aumentar la complejidad de las funciones booleanas.", "El propósito principal del Algoritmo de Quine-McCluskey es generar funciones booleanas más largas y complejas.", "Ninguna de las anteriores.", 0, true);
preguntas[22] = new Pregunta("(23)¿Cuál es la entrada típica para el Algoritmo de Quine-McCluskey?", "La entrada típica para el Algoritmo de Quine-McCluskey son los mintérminos de una función booleana que se desea simplificar.", "La entrada típica para el Algoritmo de Quine-McCluskey son los números primos de una función booleana.", "La entrada típica para el Algoritmo de Quine-McCluskey son los números enteros de una función booleana.", "Todas las anteriores.", 0, true);
preguntas[23] = new Pregunta("(24)¿Qué es un mintérmino en el contexto del Algoritmo de Quine-McCluskey?", "Un mintérmino es una expresión booleana que consiste en la productoria (AND) de todas las variables de entrada en su forma original o complementada.", "Un mintérmino es una expresión booleana que consiste en la suma (OR) de todas las variables de entrada en su forma original o complementada.", "Un mintérmino es una expresión booleana que consiste en la resta (RESTA) de todas las variables de entrada en su forma original o complementada.", "Ninguna de las anteriores.", 0, true);
preguntas[24] = new Pregunta("(25)¿Cuál es el primer paso del Algoritmo de Quine-McCluskey?", "El primer paso del Algoritmo de Quine-McCluskey implica encontrar todos los implicantes primos de la función booleana.", "El primer paso del Algoritmo de Quine-McCluskey consiste en simplificar la función booleana de inmediato.", "El primer paso del Algoritmo de Quine-McCluskey es buscar los implicantes primos esenciales.", "Todas las anteriores.", 0, true);
preguntas[25] = new Pregunta("(26)¿Qué son los implicantes primos en el contexto del Algoritmo de Quine-McCluskey?", "Los implicantes primos son términos irreducibles que cubren una o varias combinaciones de mintérminos en la función booleana.", "Los implicantes primos son términos que no tienen relación con los mintérminos en la función booleana.", "Los implicantes primos son términos complementarios a los mintérminos en la función booleana.", "Ninguna de las anteriores.", 0, true);
preguntas[26] = new Pregunta("(27)¿Cuál es el segundo paso del Algoritmo de Quine-McCluskey?", "El segundo paso del Algoritmo de Quine-McCluskey consiste en identificar los implicantes primos esenciales, que son necesarios y suficientes para generar la función simplificada.", "El segundo paso del Algoritmo de Quine-McCluskey es combinar todos los términos de la función en una única expresión.", "El segundo paso del Algoritmo de Quine-McCluskey es buscar los mintérminos que no son necesarios para la función simplificada.", "Todas las anteriores.", 0, true);
preguntas[27] = new Pregunta("(28)¿Qué se hace después de encontrar los implicantes primos esenciales en el Algoritmo de Quine-McCluskey?", "Después de encontrar los implicantes primos esenciales, se combinan para obtener la expresión simplificada de la función booleana.", "Después de encontrar los implicantes primos esenciales, se eliminan para reducir la complejidad de la función booleana. ", "Después de encontrar los implicantes primos esenciales, se utilizan como entrada en otro algoritmo para simplificar aún más la función booleana.", "Ninguna de las anteriores.", 0, true);
preguntas[28] = new Pregunta("(29)¿Cuál es el beneficio de utilizar el Algoritmo de Quine-McCluskey en lugar de otras técnicas de simplificación de funciones booleanas?", "El beneficio de utilizar el Algoritmo de Quine-McCluskey en lugar de otras técnicas de simplificación de funciones booleanas es que produce simplificaciones óptimas, lo que significa que proporciona la expresión más reducida y eficiente de una función booleana. ", "El beneficio de utilizar el Algoritmo de Quine-McCluskey es que es más rápido que otras técnicas, aunque no siempre produce la simplificación más eficiente.", "El beneficio de utilizar el Algoritmo de Quine-McCluskey es que es fácil de aprender y aplicar, lo que lo hace adecuado para principiantes en electrónica digital.", "Todas las anteriores.", 0, true);
preguntas[29] = new Pregunta("(30)¿Qué ocurre si no se encuentran implicantes primos esenciales en el Algoritmo de Quine-McCluskey?", "Si no se encuentran implicantes primos esenciales, se deben buscar implicantes primos secundarios para obtener una simplificación adecuada.", "Si no se encuentran implicantes primos esenciales, la función no se puede simplificar utilizando el Algoritmo de Quine-McCluskey.", "Si no se encuentran implicantes primos esenciales, se debe agregar más variables a la función para permitir la simplificación.", "Ninguna de las anteriores.", 0, true);
preguntas[30] = new Pregunta("(31)¿Cuál es la complejidad computacional del Algoritmo de Quine-McCluskey en términos de tiempo?", "La complejidad computacional del Algoritmo de Quine-McCluskey es exponencial en el peor de los casos, lo que significa que puede ser lento para funciones con un gran número de variables.", "La complejidad computacional del Algoritmo de Quine-McCluskey es lineal en términos de tiempo, lo que lo hace rápido y eficiente.", "La complejidad computacional del Algoritmo de Quine-McCluskey es constante, lo que significa que su rendimiento es constante independientemente del tamaño de la función.", "Todas las anteriores.", 0, true);
preguntas[31] = new Pregunta("(32)¿Qué modificaciones se han propuesto para mejorar el Algoritmo de Quine-McCluskey?", "Se han propuesto modificaciones, como la versión decimal del algoritmo, que simplifican el tratamiento de los términos No-Importa. ", "Se han propuesto modificaciones para aumentar la complejidad del Algoritmo de Quine-McCluskey y hacerlo más eficiente.", "Se han propuesto modificaciones para eliminar completamente los términos No-Importa del algoritmo.", "Ninguna de las anteriores.", 0, true);
preguntas[32] = new Pregunta("(33)¿Qué ventajas se mencionan en la versión decimal del Algoritmo de Quine-McCluskey con la modificación propuesta?", "La ventaja de la versión decimal del Algoritmo de Quine-McCluskey con la modificación propuesta es que permite tratar aritméticamente los términos No-Importa sin la necesidad de utilizar números adicionales en cada paso del algoritmo. ", "La ventaja de la versión decimal del Algoritmo de Quine-McCluskey con la modificación propuesta es que simplifica la identificación de los implicantes primos esenciales.", "La ventaja de la versión decimal del Algoritmo de Quine-McCluskey con la modificación propuesta es que elimina por completo los términos No-Importa.", "Todas las anteriores.", 0, true);
preguntas[33] = new Pregunta("(34)¿Cómo se lleva a cabo la simplificación de funciones booleanas en la versión decimal del Algoritmo de Quine-McCluskey?", "En la versión decimal del Algoritmo de Quine-McCluskey, los términos se simplifican comparando sus valores decimales, y si la diferencia entre dos términos es un múltiplo de 3, pueden generar un término reducido.", "En la versión decimal del Algoritmo de Quine-McCluskey, los términos se simplifican eliminando los valores decimales y reduciendo la función directamente.", "En la versión decimal del Algoritmo de Quine-McCluskey, los términos se simplifican mediante una representación en base 10 de los valores booleanos, lo que facilita la simplificación.", "Ninguna de las anteriores.", 0, true);
preguntas[34] = new Pregunta("(35)¿Cuál es la principal desventaja del Algoritmo de Quine-McCluskey?", "La principal desventaja del Algoritmo de Quine-McCluskey es su complejidad exponencial en el peor de los casos, lo que lo hace ineficiente para funciones con muchas variables.", "La principal desventaja del Algoritmo de Quine-McCluskey es su falta de precisión en la simplificación de funciones booleanas.", "La principal desventaja del Algoritmo de Quine-McCluskey es su incompatibilidad con la representación decimal de funciones booleanas.", "Todas las anteriores.", 0, true);
preguntas[35] = new Pregunta("(36)¿En qué aplicaciones se utiliza comúnmente el Algoritmo de Quine-McCluskey?", "El Algoritmo de Quine-McCluskey se utiliza en el diseño de circuitos lógicos, en la simplificación de funciones booleanas en electrónica digital y en la optimización de expresiones lógicas.", "El Algoritmo de Quine-McCluskey se utiliza en aplicaciones médicas para el análisis de datos clínicos.", "El Algoritmo de Quine-McCluskey se utiliza en la industria de la construcción para el cálculo de estructuras.", "Ninguna de las anteriores.", 0, true);
preguntas[36] = new Pregunta("(37)¿Cuál es el objetivo final del Algoritmo de Quine-McCluskey?", "El objetivo final del Algoritmo de Quine-McCluskey es encontrar una expresión simplificada que represente de manera eficiente una función booleana dada.", "El objetivo final del Algoritmo de Quine-McCluskey es encontrar una expresión que aumente la complejidad de una función booleana.", "El objetivo final del Algoritmo de Quine-McCluskey es encontrar todas las posibles combinaciones de variables en una función booleana.", "Todas las anteriores.", 0, true);
preguntas[37] = new Pregunta("(38)¿Qué es el principio fundamental detrás del Algoritmo de Quine-McCluskey?", "El principio fundamental detrás del Algoritmo de Quine-McCluskey es encontrar cubos que cubran la máxima cantidad de mintérminos en la función y combinarlos para obtener la simplificación óptima.", "El principio fundamental detrás del Algoritmo de Quine-McCluskey es buscar la mayor cantidad de términos complementarios en la función para aumentar su complejidad.", "El principio fundamental detrás del Algoritmo de Quine-McCluskey es dividir la función en segmentos iguales para simplificarla de manera eficiente.", "Ninguna de las anteriores.", 0, true);
preguntas[38] = new Pregunta("(39)¿Cómo se compara el Algoritmo de Quine-McCluskey con el mapa de Karnaugh en términos de aplicabilidad y eficiencia?", "El Algoritmo de Quine-McCluskey es más adecuado para funciones con un gran número de variables, mientras que el mapa de Karnaugh es más eficiente para funciones con pocas variables.", "El Algoritmo de Quine-McCluskey es más adecuado para funciones con pocas variables, mientras que el mapa de Karnaugh es más eficiente para funciones con un gran número de variables.", "El Algoritmo de Quine-McCluskey y el mapa de Karnaugh tienen la misma aplicabilidad y eficiencia en todos los casos.", "Todas las anteriores. ", 0, true);
preguntas[39] = new Pregunta("(40)¿Cuál es la importancia de la simplificación de funciones booleanas en el diseño de circuitos lógicos?", "La simplificación de funciones booleanas es crucial para reducir la complejidad y el costo de los circuitos lógicos, lo que mejora su rendimiento y eficiencia.", "La simplificación de funciones booleanas no tiene importancia en el diseño de circuitos lógicos, ya que no afecta la complejidad ni el costo.", "La simplificación de funciones booleanas aumenta la complejidad y el costo de los circuitos lógicos, lo que mejora su rendimiento.", "Ninguna de las anteriores.", 0, true);
preguntas[40] = new Pregunta("(41)¿Cuál es la función principal de una puerta lógica AND?", "La función principal de una puerta lógica AND es realizar la operación de multiplicación lógica.  ", "La función principal de una puerta lógica AND es realizar la operación de suma lógica. ", "La función principal de una puerta lógica AND es realizar la operación de negación lógica.", "Todas las anteriores.", 0, true);
preguntas[41] = new Pregunta("(42)¿Cómo se representa una puerta lógica OR en un circuito eléctrico? ", "Una puerta lógica OR se representa mediante un símbolo con dos entradas y una salida que realiza la operación de suma lógica. ", "Una puerta lógica OR se representa mediante un símbolo con una entrada y una salida que realiza la operación de multiplicación lógica. ", "Una puerta lógica OR se representa mediante un símbolo con tres entradas y dos salidas.", "Ninguna de las anteriores.", 0, true);
preguntas[42] = new Pregunta("(43)¿Cuál es la diferencia entre un circuito combinacional y un circuito secuencial? ", "Un circuito combinacional realiza operaciones lógicas basadas únicamente en las entradas actuales, mientras que un circuito secuencial tiene memoria y su salida depende de las entradas y el estado anterior. ", "La diferencia entre un circuito combinacional y un circuito secuencial radica en la complejidad de las operaciones lógicas.", "Un circuito combinacional tiene memoria, mientras que un circuito secuencial opera solo con entradas actuales.", "Todas las anteriores.", 0, true);
preguntas[43] = new Pregunta("(44)¿Qué es una tabla de verdad en el contexto de circuitos lógicos? ", "Una tabla de verdad es una representación tabular que muestra todas las posibles combinaciones de entradas y las salidas correspondientes de una función booleana. ", "Una tabla de verdad es una herramienta utilizada para programar microcontroladores. ", "Una tabla de verdad es una representación gráfica de un circuito lógico.", "Ninguna de las anteriores.", 0, true);
preguntas[44] = new Pregunta("(45)¿Por qué es importante la simplificación de expresiones booleanas en la electrónica digital? ", "La simplificación de expresiones booleanas reduce la complejidad de los circuitos y ahorra recursos, como tiempo y espacio. ", "La simplificación de expresiones booleanas aumenta la complejidad de los circuitos y mejora su rendimiento. ", "La simplificación de expresiones booleanas no tiene impacto en la electrónica digital.", "Todas las anteriores.", 0, true);
preguntas[45] = new Pregunta("(46)¿Qué son los mapas de Karnaugh y cómo se utilizan en la simplificación de funciones booleanas? ", "Los mapas de Karnaugh son herramientas gráficas que ayudan a simplificar funciones booleanas al identificar patrones de 1s en la tabla de verdad.  ", "Los mapas de Karnaugh son un tipo de dispositivo de almacenamiento de datos.", "Los mapas de Karnaugh son utilizados únicamente para aumentar la complejidad de las funciones booleanas.", "Ninguna de las anteriores.", 0, true);
preguntas[46] = new Pregunta("(47)¿Cuál es la importancia de la minimización de funciones booleanas en el diseño de circuitos lógicos? ", "La minimización de funciones booleanas es importante para reducir la complejidad y el costo de los circuitos lógicos, lo que mejora su rendimiento y eficiencia.", "La minimización de funciones booleanas aumenta la complejidad de los circuitos lógicos y los hace menos eficientes. ", "La minimización de funciones booleanas solo es relevante en la programación de software.", "Todas las anteriores.", 0, true);
preguntas[47] = new Pregunta("(48)¿Cómo se utilizan los operadores lógicos AND, OR y NOT en el Algoritmo de Quine-McCluskey para simplificar funciones booleanas? ", "Los operadores lógicos AND se utilizan para identificar términos comunes en las mintérminos, los operadores OR se utilizan para combinar términos complementarios, y los operadores NOT se utilizan para invertir variables.  ", "Los operadores lógicos AND se utilizan para invertir variables en el Algoritmo de Quine-McCluskey. ", "Los operadores lógicos AND se utilizan para combinar términos complementarios en el Algoritmo de Quine-McCluskey.", "Ninguna de las anteriores.", 0, true);
preguntas[48] = new Pregunta("(49)¿Cuál es el papel de los operadores lógicos en la representación de funciones booleanas en el contexto del Algoritmo de Quine-McCluskey? ", "Los operadores lógicos son fundamentales para definir la relación entre las variables en una función booleana y permiten expresar las operaciones lógicas necesarias para la simplificación. ", "Los operadores lógicos no tienen ningún papel en la representación de funciones booleanas en el Algoritmo de Quine-McCluskey. ", "Los operadores lógicos solo se utilizan en la implementación de circuitos, no en la representación de funciones booleanas.", "Todas las anteriores.", 0, true);
preguntas[49] = new Pregunta("(50)¿En qué medida los operadores lógicos afectan la eficiencia y la complejidad de la simplificación de funciones booleanas utilizando el Algoritmo de Quine-McCluskey? ", "Los operadores lógicos adecuados permiten simplificar funciones booleanas de manera eficiente y reducir la complejidad, mientras que un uso inadecuado puede aumentar la complejidad y dificultar la simplificación. ", "Los operadores lógicos no tienen ningún impacto en la eficiencia y la complejidad de la simplificación de funciones booleanas. ", "El uso de operadores lógicos siempre reduce la complejidad de la simplificación de funciones booleanas en el Algoritmo de Quine-McCluskey.", "Ninguna de las anteriores.", 0, true);

cuestionario();

function respuesta(n_pregunta, r){
        respuestas[n_pregunta] = r;
}

function calificar() {
    if(calif == false){
        aciertos = 0;
        for(i=0; i<correctas.length;i++){
            if(correctas[i] == respuestas[i]){
                aciertos++;
            }
    }
    aciertos = (aciertos/15)*10;
    calif = true;
    document.getElementById("resultado").innerHTML = aciertos;
    }else{
        document.getElementById("resultado").innerHTML = aciertos +"<br>(Se necesita hacer el cuestionario nuevamente 'Nuevo cuestionario')";
    }
};
